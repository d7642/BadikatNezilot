// CyberScan Pro - Complete Client-Side Implementation
// Includes: Cookie Management, Dynamic Loading, Carousel, Form Validation, 
// Lazy Loading, Drag & Drop, Infinite Scroll, Web Animations API

// ==================== COOKIE MANAGEMENT ====================
document.addEventListener('DOMContentLoaded', function() {
  const cookieBanner = document.getElementById('cookie-banner');
  const acceptAllBtn = document.getElementById('accept-all-cookies');
  const acceptEssentialBtn = document.getElementById('accept-essential-cookies');
  const customizeBtn = document.getElementById('customize-cookies');
  
  // Check if user has already made a cookie choice
  if (!getCookie('cookie-consent')) {
    if (cookieBanner) {
      cookieBanner.classList.remove('hidden');
    }
  }
  
  // Accept all cookies
  if (acceptAllBtn) {
    acceptAllBtn.addEventListener('click', function() {
      setCookie('cookie-consent', 'all', 365);
      setCookie('analytics-consent', 'true', 365);
      setCookie('marketing-consent', 'true', 365);
      if (cookieBanner) cookieBanner.classList.add('hidden');
      initializeAnalytics(); // Initialize analytics if needed
    });
  }
  
  // Accept only essential cookies
  if (acceptEssentialBtn) {
    acceptEssentialBtn.addEventListener('click', function() {
      setCookie('cookie-consent', 'essential', 365);
      setCookie('analytics-consent', 'false', 365);
      setCookie('marketing-consent', 'false', 365);
      if (cookieBanner) cookieBanner.classList.add('hidden');
    });
  }
  
  // Customize cookie settings
  if (customizeBtn) {
    customizeBtn.addEventListener('click', function() {
      // In a real implementation, this would open a modal with cookie options
      // For now, we'll treat it as accepting all
      setCookie('cookie-consent', 'all', 365);
      setCookie('analytics-consent', 'true', 365);
      setCookie('marketing-consent', 'true', 365);
      if (cookieBanner) cookieBanner.classList.add('hidden');
      initializeAnalytics(); // Initialize analytics if needed
    });
  }
  
  // Helper functions for cookie management
  function setCookie(name, value, days) {
    const expires = new Date();
    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
    document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
  }
  
  function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for(let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }
  
  // Initialize analytics if consent is given
  function initializeAnalytics() {
    // This is where you would initialize your analytics service
    // For example, Google Analytics, etc.
    if (getCookie('analytics-consent') === 'true') {
      // Initialize analytics
      console.log('Analytics initialized');
    }
  }
});

// ==================== DYNAMIC CONTENT LOADING ====================
class DynamicContentLoader {
  constructor() {
    this.contentContainer = document.getElementById('main-content');
    this.loadingIndicator = document.getElementById('loading-indicator');
    this.init();
  }
  
  init() {
    // Handle navigation clicks
    document.addEventListener('click', (e) => {
      if (e.target.matches('[data-load-page]')) {
        e.preventDefault();
        const page = e.target.getAttribute('data-load-page');
        this.loadPage(page);
      }
    });
    
    // Handle browser back/forward buttons
    window.addEventListener('popstate', (e) => {
      if (e.state && e.state.page) {
        this.loadPage(e.state.page, false);
      }
    });
  }
  
  async loadPage(page, pushState = true) {
    try {
      // Show loading indicator
      if (this.loadingIndicator) {
        this.loadingIndicator.style.display = 'block';
      }
      
      // Fetch page content (in a real app, this would be an actual fetch)
      // For demo purposes, we'll simulate content
      const html = `<div>
        <h2>${page.charAt(0).toUpperCase() + page.slice(1)} Page</h2>
        <p>This content was loaded dynamically without a full page refresh.</p>
        <button data-load-page="home">Go Home</button>
      </div>`;
      
      // Update content
      if (this.contentContainer) {
        this.contentContainer.innerHTML = html;
      }
      
      // Update browser history
      if (pushState) {
        history.pushState({ page }, '', `/${page}`);
      }
      
      // Re-initialize any components that need it
      this.initializeComponents();
    } catch (error) {
      console.error('Error loading page:', error);
      if (this.contentContainer) {
        this.contentContainer.innerHTML = '<p>Failed to load content. Please try again.</p>';
      }
    } finally {
      // Hide loading indicator
      if (this.loadingIndicator) {
        this.loadingIndicator.style.display = 'none';
      }
    }
  }
  
  initializeComponents() {
    // Re-initialize any components that might have been added dynamically
    initializeForms();
    initializeCarousels();
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  window.contentLoader = new DynamicContentLoader();
});

// ==================== CAROUSEL IMPLEMENTATION ====================
class Carousel {
  constructor(element) {
    this.carousel = element;
    this.slides = this.carousel.querySelectorAll('.carousel-slide');
    this.indicators = this.carousel.querySelectorAll('.carousel-indicator');
    this.prevBtn = this.carousel.querySelector('.carousel-prev');
    this.nextBtn = this.carousel.querySelector('.carousel-next');
    this.currentIndex = 0;
    this.autoPlayInterval = null;
    
    this.init();
  }
  
  init() {
    // Set up initial state
    this.updateCarousel();
    
    // Add event listeners
    if (this.prevBtn) {
      this.prevBtn.addEventListener('click', () => this.prevSlide());
    }
    
    if (this.nextBtn) {
      this.nextBtn.addEventListener('click', () => this.nextSlide());
    }
    
    // Indicator clicks
    this.indicators.forEach((indicator, index) => {
      indicator.addEventListener('click', () => this.goToSlide(index));
    });
    
    // Auto-play
    this.startAutoPlay();
    
    // Pause auto-play on hover
    this.carousel.addEventListener('mouseenter', () => this.stopAutoPlay());
    this.carousel.addEventListener('mouseleave', () => this.startAutoPlay());
  }
  
  updateCarousel() {
    // Update slide positions
    this.slides.forEach((slide, index) => {
      slide.classList.toggle('active', index === this.currentIndex);
    });
    
    // Update indicators
    this.indicators.forEach((indicator, index) => {
      indicator.classList.toggle('active', index === this.currentIndex);
    });
  }
  
  goToSlide(index) {
    this.currentIndex = index;
    this.updateCarousel();
  }
  
  nextSlide() {
    this.currentIndex = (this.currentIndex + 1) % this.slides.length;
    this.updateCarousel();
  }
  
  prevSlide() {
    this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;
    this.updateCarousel();
  }
  
  startAutoPlay() {
    this.stopAutoPlay(); // Clear any existing interval
    this.autoPlayInterval = setInterval(() => {
      this.nextSlide();
    }, 5000); // Change slide every 5 seconds
  }
  
  stopAutoPlay() {
    if (this.autoPlayInterval) {
      clearInterval(this.autoPlayInterval);
      this.autoPlayInterval = null;
    }
  }
}

// Initialize all carousels on the page
function initializeCarousels() {
  document.querySelectorAll('.carousel').forEach(carousel => {
    new Carousel(carousel);
  });
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeCarousels);

// ==================== FORM VALIDATION ====================
function initializeForms() {
  // Get all forms with validation
  const forms = document.querySelectorAll('form[data-validate]');
  
  forms.forEach(form => {
    form.addEventListener('submit', function(e) {
      if (!validateForm(this)) {
        e.preventDefault();
      }
    });
    
    // Real-time validation on input
    const inputs = form.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
      input.addEventListener('blur', () => validateField(input));
      input.addEventListener('input', () => clearFieldError(input));
    });
  });
}

function validateForm(form) {
  let isValid = true;
  const inputs = form.querySelectorAll('input, textarea, select');
  
  inputs.forEach(input => {
    if (!validateField(input)) {
      isValid = false;
    }
  });
  
  return isValid;
}

function validateField(field) {
  // Clear any existing error
  clearFieldError(field);
  
  const value = field.value.trim();
  const isRequired = field.hasAttribute('required');
  const type = field.getAttribute('type') || field.tagName.toLowerCase();
  
  // Check if field is required and empty
  if (isRequired && !value) {
    showFieldError(field, 'This field is required');
    return false;
  }
  
  // Type-specific validation
  switch (type) {
    case 'email':
      if (value && !isValidEmail(value)) {
        showFieldError(field, 'Please enter a valid email address');
        return false;
      }
      break;
    case 'url':
      if (value && !isValidURL(value)) {
        showFieldError(field, 'Please enter a valid URL');
        return false;
      }
      break;
    case 'password':
      if (value && value.length < 8) {
        showFieldError(field, 'Password must be at least 8 characters');
        return false;
      }
      break;
    case 'checkbox':
      if (isRequired && !field.checked) {
        showFieldError(field, 'This field is required');
        return false;
      }
      break;
  }
  
  // Custom validation patterns
  const pattern = field.getAttribute('pattern');
  if (pattern && value) {
    const regex = new RegExp(pattern);
    if (!regex.test(value)) {
      const errorMessage = field.getAttribute('data-error-message') || 'Please enter a valid value';
      showFieldError(field, errorMessage);
      return false;
    }
  }
  
  return true;
}

function isValidEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function isValidURL(url) {
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
}

function showFieldError(field, message) {
  // Add error class
  field.classList.add('error');
  
  // Create or update error message
  let errorElement = field.parentNode.querySelector('.field-error');
  if (!errorElement) {
    errorElement = document.createElement('div');
    errorElement.className = 'field-error';
    field.parentNode.appendChild(errorElement);
  }
  
  errorElement.textContent = message;
}

function clearFieldError(field) {
  field.classList.remove('error');
  const errorElement = field.parentNode.querySelector('.field-error');
  if (errorElement) {
    errorElement.remove();
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', initializeForms);

// ==================== LAZY LOADING ====================
class LazyLoader {
  constructor() {
    this.imageObserver = null;
    this.init();
  }
  
  init() {
    // Check if Intersection Observer is supported
    if ('IntersectionObserver' in window) {
      this.imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            this.loadImage(img);
            observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px 0px' // Load images 50px before they come into view
      });
      
      // Observe all lazy images
      document.querySelectorAll('img[data-src]').forEach(img => {
        this.imageObserver.observe(img);
      });
    } else {
      // Fallback for browsers that don't support Intersection Observer
      this.loadAllImages();
    }
  }
  
  loadImage(img) {
    const src = img.getAttribute('data-src');
    if (src) {
      img.src = src;
      img.removeAttribute('data-src');
      img.classList.add('loaded');
    }
  }
  
  loadAllImages() {
    document.querySelectorAll('img[data-src]').forEach(img => {
      this.loadImage(img);
    });
  }
}

// Initialize lazy loading when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new LazyLoader();
});

// ==================== INFINITE SCROLL ====================
class InfiniteScroll {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      threshold: 0.1,
      apiUrl: '/api/load-more',
      ...options
    };
    this.isLoading = false;
    this.hasMore = true;
    this.page = 1;
    
    this.init();
  }
  
  init() {
    // Create observer
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.isLoading && this.hasMore) {
            this.loadMore();
          }
        });
      },
      { threshold: this.options.threshold }
    );
    
    // Observe sentinel element
    const sentinel = document.createElement('div');
    sentinel.id = 'infinite-scroll-sentinel';
    if (this.container) {
      this.container.appendChild(sentinel);
      this.observer.observe(sentinel);
    }
  }
  
  async loadMore() {
    if (this.isLoading) return;
    
    this.isLoading = true;
    
    try {
      // Show loading indicator
      const loadingElement = document.createElement('div');
      loadingElement.id = 'infinite-scroll-loading';
      loadingElement.textContent = 'Loading more...';
      if (this.container) {
        this.container.appendChild(loadingElement);
      }
      
      // Simulate fetching more content
      // In a real app, you would fetch from an API
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Remove loading indicator
      loadingElement.remove();
      
      // Sample data for demo
      const sampleItems = [
        { title: 'Vulnerability 1', description: 'Description of vulnerability 1' },
        { title: 'Vulnerability 2', description: 'Description of vulnerability 2' },
        { title: 'Vulnerability 3', description: 'Description of vulnerability 3' }
      ];
      
      if (sampleItems.length > 0 && this.page < 3) { // Limit to 3 pages for demo
        // Add new items to container
        sampleItems.forEach(item => {
          const itemElement = this.createItemElement(item);
          if (this.container) {
            this.container.insertBefore(itemElement, document.getElementById('infinite-scroll-sentinel'));
          }
        });
        
        this.page++;
      } else {
        // No more items
        this.hasMore = false;
        this.showEndMessage();
      }
    } catch (error) {
      console.error('Error loading more items:', error);
      this.showError();
    } finally {
      this.isLoading = false;
    }
  }
  
  createItemElement(item) {
    // Create DOM element for item
    const element = document.createElement('div');
    element.className = 'infinite-scroll-item';
    element.innerHTML = `
      <h3>${item.title}</h3>
      <p>${item.description}</p>
    `;
    return element;
  }
  
  showEndMessage() {
    const endElement = document.createElement('div');
    endElement.id = 'infinite-scroll-end';
    endElement.textContent = 'You have reached the end';
    if (this.container) {
      this.container.appendChild(endElement);
    }
  }
  
  showError() {
    const errorElement = document.createElement('div');
    errorElement.id = 'infinite-scroll-error';
    errorElement.textContent = 'Failed to load more items';
    if (this.container) {
      this.container.appendChild(errorElement);
    }
  }
}

// Initialize infinite scroll
document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('results-container');
  if (container) {
    new InfiniteScroll(container);
  }
});

// ==================== DRAG AND DROP ====================
class DragAndDrop {
  constructor(container) {
    this.container = container;
    this.draggedItem = null;
    this.init();
  }
  
  init() {
    if (!this.container) return;
    
    this.container.addEventListener('dragstart', (e) => this.handleDragStart(e));
    this.container.addEventListener('dragover', (e) => this.handleDragOver(e));
    this.container.addEventListener('dragenter', (e) => this.handleDragEnter(e));
    this.container.addEventListener('dragleave', (e) => this.handleDragLeave(e));
    this.container.addEventListener('drop', (e) => this.handleDrop(e));
    this.container.addEventListener('dragend', (e) => this.handleDragEnd(e));
  }
  
  handleDragStart(e) {
    this.draggedItem = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target.innerHTML);
  }
  
  handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
  }
  
  handleDragEnter(e) {
    e.preventDefault();
    if (e.target.classList.contains('drop-zone')) {
      e.target.classList.add('drag-over');
    }
  }
  
  handleDragLeave(e) {
    if (e.target.classList.contains('drop-zone')) {
      e.target.classList.remove('drag-over');
    }
  }
  
  handleDrop(e) {
    e.stopPropagation();
    
    if (e.target.classList.contains('drop-zone')) {
      e.target.classList.remove('drag-over');
      
      // Add the dragged item to the drop zone
      const newItem = document.createElement('div');
      newItem.className = 'draggable-item';
      newItem.innerHTML = this.draggedItem.innerHTML;
      newItem.draggable = true;
      e.target.appendChild(newItem);
      
      // Remove the original item
      this.draggedItem.remove();
    }
    
    return false;
  }
  
  handleDragEnd(e) {
    if (e.target) {
      e.target.classList.remove('dragging');
    }
    document.querySelectorAll('.drag-over').forEach(zone => {
      zone.classList.remove('drag-over');
    });
  }
}

// Initialize drag and drop when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.drag-container').forEach(container => {
    new DragAndDrop(container);
  });
});

// ==================== WEB ANIMATIONS API ====================
class WebAnimator {
  constructor() {
    this.init();
  }
  
  init() {
    // Animate elements when they come into view
    document.addEventListener('DOMContentLoaded', () => {
      this.animateOnScroll();
    });
    
    // Add hover animations to buttons
    this.addHoverAnimations();
  }
  
  animateOnScroll() {
    // Create observer for scroll animations
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.animateElement(entry.target);
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    
    // Observe elements with animation classes
    document.querySelectorAll('.animate-on-scroll').forEach(el => {
      observer.observe(el);
    });
  }
  
  animateElement(element) {
    // Different animations based on data attribute
    const animationType = element.getAttribute('data-animation') || 'fadeIn';
    
    let keyframes, options;
    
    switch (animationType) {
      case 'fadeIn':
        keyframes = [
          { opacity: 0 },
          { opacity: 1 }
        ];
        options = {
          duration: 600,
          easing: 'ease-out'
        };
        break;
        
      case 'slideInLeft':
        keyframes = [
          { transform: 'translateX(-100%)', opacity: 0 },
          { transform: 'translateX(0)', opacity: 1 }
        ];
        options = {
          duration: 800,
          easing: 'ease-out'
        };
        break;
        
      case 'slideInRight':
        keyframes = [
          { transform: 'translateX(100%)', opacity: 0 },
          { transform: 'translateX(0)', opacity: 1 }
        ];
        options = {
          duration: 800,
          easing: 'ease-out'
        };
        break;
        
      case 'slideUp':
        keyframes = [
          { transform: 'translateY(50px)', opacity: 0 },
          { transform: 'translateY(0)', opacity: 1 }
        ];
        options = {
          duration: 600,
          easing: 'ease-out'
        };
        break;
        
      default:
        return;
    }
    
    // Check if Web Animations API is supported
    if (element.animate) {
      element.animate(keyframes, options);
    }
    
    // Add a class to keep the final state
    element.classList.add('animated');
  }
  
  addHoverAnimations() {
    // Add hover animations to buttons
    document.querySelectorAll('button, .btn').forEach(button => {
      // Check if Web Animations API is supported
      if (button.animate) {
        button.addEventListener('mouseenter', (e) => {
          e.target.animate([
            { transform: 'scale(1)' },
            { transform: 'scale(1.05)' }
          ], {
            duration: 200,
            fill: 'forwards'
          });
        });
        
        button.addEventListener('mouseleave', (e) => {
          e.target.animate([
            { transform: 'scale(1.05)' },
            { transform: 'scale(1)' }
          ], {
            duration: 200,
            fill: 'forwards'
          });
        });
      }
    });
  }
}

// Initialize web animations when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new WebAnimator();
});

// ==================== SERVICE WORKER REGISTRATION ====================
// Check if service workers are supported
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('Service Worker registered with scope:', registration.scope);
      })
      .catch((error) => {
        console.log('Service Worker registration failed:', error);
      });
  });
}

// ==================== LOCAL/SESSION STORAGE EXAMPLES ====================
// Example of using localStorage
function saveUserPreferences(preferences) {
  try {
    localStorage.setItem('userPreferences', JSON.stringify(preferences));
  } catch (e) {
    console.error('Failed to save preferences to localStorage', e);
  }
}

function getUserPreferences() {
  try {
    const preferences = localStorage.getItem('userPreferences');
    return preferences ? JSON.parse(preferences) : null;
  } catch (e) {
    console.error('Failed to retrieve preferences from localStorage', e);
    return null;
  }
}

// Example of using sessionStorage
function saveScanResults(results) {
  try {
    sessionStorage.setItem('scanResults', JSON.stringify(results));
  } catch (e) {
    console.error('Failed to save scan results to sessionStorage', e);
  }
}

function getScanResults() {
  try {
    const results = sessionStorage.getItem('scanResults');
    return results ? JSON.parse(results) : null;
  } catch (e) {
    console.error('Failed to retrieve scan results from sessionStorage', e);
    return null;
  }
}

// ==================== COMPLETE DOM READY INITIALIZATION ====================
document.addEventListener('DOMContentLoaded', function() {
  console.log('CyberScan Pro client-side functionality initialized');
  
  // Initialize all components
  initializeForms();
  initializeCarousels();
  
  // Initialize other components as needed
  // Web animations, lazy loading, etc. are initialized in their own modules
});